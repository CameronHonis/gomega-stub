package stub_test

import (
	"fmt"
	. "github.com/CameronHonis/stub"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

type Object struct {
	FieldA string
}

func NewObject() *Object {
	return &Object{
		FieldA: "fieldA",
	}
}

func (o *Object) GetFieldA() string {
	return o.FieldA
}

func (o *Object) SetFieldA(fieldA string) {
	o.FieldA = fieldA
}

func (o *Object) Add(a, b int) int {
	return a + b
}

func (o *Object) Divide(a, b int) (int, error) {
	if b == 0 {
		return 0, fmt.Errorf("cannot divide by zero")
	}
	return a / b, nil
}

func (o *Object) privateMethod() string {
	return "ello, poppet"
}

// NOTE: the StubbedObject definition below would be automatically generated by the generator
//	provided by this package. The generator would be run as a separate step in the build process.
//	The generator would also create the constructor and the method overrides on the base struct.
type StubbedObject struct {
	Mocked[Object]
}

func NewStubbedObject() *StubbedObject {
	so := &StubbedObject{}
	so.Mocked = *NewMocked[Object](so, NewObject())
	return so
}

func (s *StubbedObject) GetFieldA() string {
	out := s.Call("GetFieldA")
	return out[0].(string)
}

func (s *StubbedObject) SetFieldA(fieldA string) {
	s.Call("SetFieldA", fieldA)
}

func (s *StubbedObject) Add(a, b int) int {
	out := s.Call("Add", a, b)
	return out[0].(int)
}

func (s *StubbedObject) Divide(a, b int) (int, error) {
	out := s.Call("Divide", a, b)
	return out[0].(int), out[1].(error)
}

func (s *StubbedObject) privateMethod() string {
	out := s.Call("privateMethod")
	return out[0].(string)
}

var _ = Describe("Mocked", func() {
	var stubbedObject *StubbedObject
	BeforeEach(func() {
		stubbedObject = NewStubbedObject()
	})
	Describe("Stub", func() {
		It("adds the method to the stubbed object context", func() {
			methodStub := func(rec *Object) string {
				return "hello"
			}
			stubbedObject.Stub("GetFieldA", methodStub)
			Expect(stubbedObject.IsStubbed("GetFieldA")).To(BeTrue())
		})
		When("the method name passed does not exist on the struct", func() {
			It("panics", func() {
				Expect(func() {
					stubbedObject.Stub("someNonExistentMethod", func() {})
				}).To(Panic())
			})
		})
		When("the method stub is not typed properly", func() {
			When("the return type is incorrect", func() {
				It("panics", func() {
					Expect(func() {
						stubbedObject.Stub("GetFieldA", func() {})
					}).To(Panic())
				})
			})
			When("the number of arguments is incorrect", func() {
				It("panics", func() {
					Expect(func() {
						stubbedObject.Stub("Add", func(rec *Object, a int) int {
							return 0
						})
					}).To(Panic())
				})
			})
			When("the argument types are incorrect", func() {
				It("panics", func() {
					Expect(func() {
						stubbedObject.Stub("Add", func(rec *Object, a, b string) int {
							return 0
						})
					}).To(Panic())
				})
			})
		})
	})
	Describe("Unstub", func() {
		BeforeEach(func() {
			stubbedObject.Stub("GetFieldA", func(rec *Object) string {
				return "hello"
			})
		})
		It("removes the method from the stubbed object context", func() {
			stubbedObject.Unstub("GetFieldA")
			Expect(stubbedObject.IsStubbed("GetFieldA")).To(BeFalse())
		})
	})
	Describe("Call", func() {
		It("records the method call", func() {
			stubbedObject.Call("Add", 1, 2)
			Expect(stubbedObject.MethodCallCount("Add")).To(Equal(1))
			addCalls := stubbedObject.AllCallArgs("Add")
			Expect(addCalls).To(HaveLen(1))
			Expect(addCalls[0]).To(Equal([]interface{}{1, 2}))
		})
		When("the method is not stubbed", func() {
			It("calls the original method", func() {
				stubbedObject.Call("SetFieldA", "changedFieldA")
				Expect(stubbedObject.GetFieldA()).To(Equal("changedFieldA"))
			})
		})
		When("the method is stubbed", func() {
			BeforeEach(func() {
				stubbedObject.Stub("GetFieldA", func(rec *Object) string {
					return "stubbedFieldA"
				})
			})
			It("calls the stubbed method", func() {
				out := stubbedObject.Call("GetFieldA")
				Expect(out).To(HaveLen(1))
				Expect(out[0].(string)).To(Equal("stubbedFieldA"))
			})
			When("its called with the wrong number of arguments", func() {
				It("panics", func() {
					Expect(func() {
						stubbedObject.Call("GetFieldA", "some-invalid-arg")
					}).To(Panic())
				})
			})
			When("its called with the wrong argument types", func() {
				BeforeEach(func() {
					stubbedObject.Stub("Add", func(rec *Object, a, b int) int {
						return 0
					})
				})
				It("panics", func() {
					Expect(func() {
						stubbedObject.Call("Add", "one", "two")
					}).To(Panic())
				})
			})
		})
		// NOTE: since reflect cannot interact with private methods, stub will not work on private methods
		PWhen("the method is private", func() {
			When("the method is stubbed", func() {
				BeforeEach(func() {
					stubbedObject.Stub("privateMethod", func(rec *Object) string {
						return "good ay, mate!"
					})
				})
				It("calls the stubbing function", func() {
					Expect(stubbedObject.privateMethod()).To(Equal("good ay, mate!"))

				})
				It("tracks the call args", func() {
					stubbedObject.privateMethod()
					callArgs := stubbedObject.Mocked.LastCallArgs("privateMethod")
					Expect(callArgs).To(HaveLen(0))
				})
			})
			When("the method is not stubbed", func() {
				It("calls the original method as expected", func() {
					Expect(stubbedObject.privateMethod()).To(Equal("ello, poppet"))
				})
				It("tracks the call args", func() {
					stubbedObject.privateMethod()
					callArgs := stubbedObject.LastCallArgs("privateMethod")
					Expect(callArgs).To(HaveLen(0))
				})
			})
		})
	})
})
